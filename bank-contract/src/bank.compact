// Midnight Bank - Privacy-Preserving Banking DApp (Shared Contract Architecture)
// Demonstrates: ZK Proofs, Private State, Confidential Contracts, Inter-Account Transfers

pragma language_version >= 0.13.0;

import CompactStandardLibrary;

// Export types for external use
export { CoinInfo };

// Bank Account structure for the shared ledger
struct BankAccount {
  exists: Boolean,
  owner_hash: Bytes<32>,
  public_key: ZswapCoinPublicKey,
  transaction_count: Uint<32>,
  last_transaction: Bytes<32>,
  status: Bytes<32>,
  created_at: Uint<32>
}

// Authorization structures for Zelle-like transfers
struct TransferAuthorization {
  sender_id: Bytes<32>,
  recipient_id: Bytes<32>,
  shared_encryption_key: Bytes<32>,
  max_amount: Uint<64>,
  created_at: Uint<32>,
  last_updated: Uint<32>
}

struct AuthRequest {
  sender_id: Bytes<32>,
  recipient_id: Bytes<32>,
  requested_at: Uint<32>,
  status: Uint<8>
}

enum AUTH_STATUS {
  pending,
  approved,
  rejected
}

// Public ledger state - ALL ACCOUNTS IN ONE CONTRACT
export ledger all_accounts: Map<Bytes<32>, BankAccount>;  // Maps user_id -> account info
export ledger total_accounts: Counter;                    // Total number of accounts
export ledger last_global_transaction: Bytes<32>;         // Latest transaction hash

// Authorization system for Zelle-like transfers
export ledger active_authorizations: Map<Bytes<32>, TransferAuthorization>; // auth_id -> authorization
export ledger encrypted_balances: Map<Bytes<32>, Bytes<32>>;                // auth_id -> encrypted_balance
export ledger pending_auth_requests: Map<Bytes<32>, AuthRequest>;           // request_id -> request
export ledger user_as_recipient_auths: Map<Bytes<32>, Vector<20, Bytes<32>>>; // user_id -> auth_ids
export ledger user_as_sender_auths: Map<Bytes<32>, Vector<20, Bytes<32>>>;   // user_id -> auth_ids

// Encrypted token amount mappings (contract-wide accessible)
export ledger encrypted_amount_mappings: Map<Bytes<32>, Uint<64>>;          // encrypted_balance -> actual_amount

// Private data (user-specific, stored per user)
witness user_pin_hash(user_id: Bytes<32>): Bytes<32>;
witness user_balance(user_id: Bytes<32>): Uint<64>;
witness set_user_balance(user_id: Bytes<32>, balance: Uint<64>): [];
// Note: Transaction history removed - API handles detailed transaction logging

// Constructor - Initialize empty shared bank
constructor() {
  last_global_transaction = pad(32, "bank_initialized");
}

// Circuit 1: Create Account in Shared Bank
export circuit create_account(user_id: Bytes<32>, initial_pin: Bytes<32>, deposit_amount: Uint<64>): [] {
  // Check account doesn't already exist
  assert (!all_accounts.member(disclose(user_id)), "Account already exists");
  
  assert (deposit_amount >= 10 as Uint<64>, "Minimum deposit is 10 coins");
  assert (valid_pin_format(initial_pin), "PIN must be valid format");
  
  // Create account identity
  const owner_id = disclose(public_key(initial_pin));
  
  // Create new account in shared ledger
  const new_account = BankAccount {
    exists: true,
    owner_hash: owner_id,
    public_key: ownPublicKey(),
    transaction_count: 1 as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "account_created")),
    status: pad(32, "active"),
    created_at: 1 as Uint<32> // Would be block timestamp in real implementation
  };
  
  all_accounts.insert(disclose(user_id), new_account);
  total_accounts.increment(1);
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "account_created"), user_id]));
  
  // Initialize private state for this user
  set_user_balance(user_id, deposit_amount);
}

// Circuit 2: Deposit to User Account
export circuit deposit(user_id: Bytes<32>, pin: Bytes<32>, amount: Uint<64>): [] {
  assert (amount > 0 as Uint<64>, "Deposit amount must be positive");
  
  // Get account from shared ledger
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Update private balance
  const current_balance = user_balance(user_id);
  const new_balance = current_balance + amount;
  set_user_balance(user_id, new_balance as Uint<64>);
  
  // Update public account state
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "deposit")),
    status: pad(32, "active"),
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "deposit"), user_id]));
}

// Circuit 3: Withdraw from User Account  
export circuit withdraw(user_id: Bytes<32>, pin: Bytes<32>, amount: Uint<64>): [] {
  assert (amount > 0 as Uint<64>, "Withdrawal amount must be positive");
  
  // Get account from shared ledger
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Check and update private balance
  const current_balance = user_balance(user_id);
  assert (current_balance >= amount, "Insufficient funds");
  const new_balance = current_balance - amount;
  set_user_balance(user_id, new_balance as Uint<64>);
  
  // Update public account state
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "withdrawal")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "withdrawal"), user_id]));
}

// Circuit 4: Request Transfer Authorization (Like Adding Contact on Zelle)
export circuit request_transfer_authorization(user_id: Bytes<32>, recipient_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (user_id != recipient_id, "Cannot authorize yourself");
  assert (all_accounts.member(disclose(recipient_id)), "Recipient account does not exist");
  
  // Authenticate sender
  assert (all_accounts.member(disclose(user_id)), "Sender account does not exist");
  const sender_account = all_accounts.lookup(disclose(user_id));
  assert (sender_account.owner_hash == public_key(pin), "Authentication failed");
  
  const request_id = persistentHash<Vector<2, Bytes<32>>>([user_id, recipient_id]);
  
  const request = AuthRequest {
    sender_id: disclose(user_id),
    recipient_id: disclose(recipient_id),
    requested_at: 1, // current timestamp
    status: 0 as Uint<8> // AUTH_STATUS.pending
  };
  
  pending_auth_requests.insert(disclose(request_id), request);
  
  // Update sender's transaction count
  const updated_sender = BankAccount {
    exists: sender_account.exists,
    owner_hash: sender_account.owner_hash,
    public_key: sender_account.public_key,
    transaction_count: (sender_account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "auth_requested")),
    status: sender_account.status,
    created_at: sender_account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_sender);
}

// Circuit 5: Approve Transfer Authorization (One-Time Setup)
export circuit approve_transfer_authorization(user_id: Bytes<32>, sender_id: Bytes<32>, pin: Bytes<32>, max_amount: Uint<64>): [] {
  // 1. Verify request exists
  const request_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  assert (pending_auth_requests.member(disclose(request_id)), "No pending authorization request");
  
  // 2. Authenticate recipient
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  assert (account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Generate shared encryption key and auth_id
  const shared_key = persistentHash<Vector<3, Bytes<32>>>([user_id, sender_id, persistentHash<Bytes<32>>(pin)]);
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  
  // 4. Create authorization
  const authorization = TransferAuthorization {
    sender_id: disclose(sender_id),
    recipient_id: disclose(user_id),
    shared_encryption_key: disclose(shared_key),
    max_amount: disclose(max_amount),
    created_at: 1,
    last_updated: 1
  };
  
  // 5. Store authorization and initialize encrypted transfer amounts to zero
  active_authorizations.insert(disclose(auth_id), authorization);
  const zero_amount = 0 as Uint<64>;
  const encrypted_zero = encrypt_balance(zero_amount, disclose(shared_key));
  encrypted_balances.insert(disclose(auth_id), encrypted_zero);
  
  // 6. Update lookup tables (simplified - using single entry for now)
  const empty_vector: Vector<20, Bytes<32>> = [pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, "")];
  const recipient_auths = user_as_recipient_auths.member(disclose(user_id)) ? 
    user_as_recipient_auths.lookup(disclose(user_id)) : empty_vector;
  const updated_recipient_auths = [disclose(auth_id), recipient_auths[0], recipient_auths[1], recipient_auths[2], recipient_auths[3],
                                  recipient_auths[4], recipient_auths[5], recipient_auths[6], recipient_auths[7], recipient_auths[8],
                                  recipient_auths[9], recipient_auths[10], recipient_auths[11], recipient_auths[12], recipient_auths[13],
                                  recipient_auths[14], recipient_auths[15], recipient_auths[16], recipient_auths[17], recipient_auths[18]];
  user_as_recipient_auths.insert(disclose(user_id), updated_recipient_auths);
  
  // 7. Clean up request
  pending_auth_requests.remove(disclose(request_id));
  
  // 8. Update account
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "auth_approved")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Circuit 6: Send to Authorized User (Simplified for now)
export circuit send_to_authorized_user(user_id: Bytes<32>, recipient_id: Bytes<32>, amount: Uint<64>, pin: Bytes<32>): [] {
  assert (amount > 0 as Uint<64>, "Transfer amount must be positive");
  assert (user_id != recipient_id, "Cannot transfer to yourself");
  
  // 1. Verify authorization exists
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([user_id, recipient_id]);
  assert (active_authorizations.member(disclose(auth_id)), "No authorization - recipient must approve first");
  
  const auth = active_authorizations.lookup(disclose(auth_id));
  assert (amount <= auth.max_amount, "Amount exceeds authorized limit");
  
  // 2. Authenticate sender
  assert (all_accounts.member(disclose(user_id)), "Sender account does not exist");
  const sender_account = all_accounts.lookup(disclose(user_id));
  assert (sender_account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Verify sender has sufficient funds and transfer
  const sender_balance = user_balance(user_id);
  assert (sender_balance >= amount, "Insufficient funds");
  set_user_balance(user_id, (sender_balance - amount) as Uint<64>);
  
  // 4. Store/accumulate pending transfer for recipient to claim later
  const pending_amount = encrypted_balances.member(disclose(auth_id)) ?
    encrypted_balances.lookup(disclose(auth_id)) : encrypt_balance(0 as Uint<64>, auth.shared_encryption_key);

  // Resolve current total (if any) from the public mapping
  const has_mapping = encrypted_amount_mappings.member(pending_amount);
  const current_total = has_mapping ? encrypted_amount_mappings.lookup(pending_amount) : 0 as Uint<64>;
  const new_total = (current_total + amount) as Uint<64>;

  // Encrypt the new total and update mapping and encrypted balance
  const new_encrypted_amount = encrypt_balance(disclose(new_total), disclose(auth.shared_encryption_key));

  // Clear old mapping entry to avoid leaking stale totals
  if (has_mapping) {
    encrypted_amount_mappings.insert(pending_amount, 0 as Uint<64>);
  }
  encrypted_amount_mappings.insert(new_encrypted_amount, disclose(new_total));
  encrypted_balances.insert(disclose(auth_id), new_encrypted_amount);
  
  // 5. Update sender's account
  const updated_sender = BankAccount {
    exists: sender_account.exists,
    owner_hash: sender_account.owner_hash,
    public_key: sender_account.public_key,
    transaction_count: (sender_account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "auth_transfer_sent")),
    status: sender_account.status,
    created_at: sender_account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_sender);
  
  // Transaction completed - history tracked by API
  
  last_global_transaction = disclose(persistentHash<Vector<3, Bytes<32>>>([pad(32, "auth_transfer"), user_id, recipient_id]));
}

// Circuit 7: Claim Authorized Transfer
export circuit claim_authorized_transfer(user_id: Bytes<32>, sender_id: Bytes<32>, pin: Bytes<32>): [] {
  // 1. Verify authorization exists
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  assert (active_authorizations.member(disclose(auth_id)), "No authorization exists");
  
  // 2. Authenticate recipient
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  assert (account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Check if there's a pending transfer to claim
  assert (encrypted_balances.member(disclose(auth_id)), "No pending transfer to claim");
  const encrypted_amount = encrypted_balances.lookup(disclose(auth_id));
  
  // 4. Reconstruct shared encryption key and decrypt amount
  const auth = active_authorizations.lookup(disclose(auth_id));
  const shared_key = persistentHash<Vector<3, Bytes<32>>>([user_id, sender_id, persistentHash<Bytes<32>>(pin)]);
  assert (auth.shared_encryption_key == disclose(shared_key), "Invalid encryption key");
  
  // 5. Look up the pending amount from public ledger
  assert (encrypted_amount_mappings.member(encrypted_amount), "No pending transfer found");
  const pending_amount = encrypted_amount_mappings.lookup(encrypted_amount);
  assert (pending_amount > 0 as Uint<64>, "No pending amount to claim");
  
  // 6. Add to recipient's balance
  const current_balance = user_balance(user_id);
  set_user_balance(user_id, (current_balance + pending_amount) as Uint<64>);
  
  // 7. Clear the claimed transfer (set to zero) 
  const zero_encrypted = encrypt_balance(0 as Uint<64>, disclose(shared_key));
  encrypted_balances.insert(disclose(auth_id), zero_encrypted);
  
  // Clear the amount mapping from public ledger
  encrypted_amount_mappings.insert(encrypted_amount, 0 as Uint<64>);
  
  // 8. Update recipient's account and transaction history
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "transfer_claimed")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  // Transfer claimed - history tracked by API
  
  last_global_transaction = disclose(persistentHash<Vector<3, Bytes<32>>>([pad(32, "transfer_claimed"), sender_id, user_id]));
}

// Circuit 5: Authenticate Balance Access
export circuit authenticate_balance_access(user_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Update last transaction to show balance was checked
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: account.transaction_count,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "balance_check")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Circuit 6: Verify Account Status
export circuit verify_account_status(user_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Verify account properties
  const balance = user_balance(user_id);
  assert (balance >= 5 as Uint<64>, "Account balance too low for verification");
  assert (account.transaction_count >= 1 as Uint<32>, "Insufficient transaction history");
  
  // Update verification status
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: account.transaction_count,
    last_transaction: account.last_transaction,
    status: pad(32, "verified"),
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Helper Functions
pure circuit valid_pin_format(pin: Bytes<32>): Boolean {
  const zero_pin = pad(32, "");
  return pin != zero_pin;
}

export pure circuit public_key(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight:bank:pk:"), sk]);
}

// Helper Functions for Encryption (Authorization System)
// Using XOR with key derivation for symmetric encryption/decryption
pure circuit encrypt_balance(balance: Uint<64>, encryption_key: Bytes<32>): Bytes<32> {
  // Convert balance to bytes for XOR encryption
  const balance_bytes = pad(32, "");
  // Simple but secure XOR encryption - in production would use AES or similar
  const encrypted = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Uint<64>>(balance), 
    encryption_key
  ]);
  return encrypted;
}