// Midnight Bank - Privacy-Preserving Banking DApp (Shared Contract Architecture)
// Demonstrates: ZK Proofs, Private State, Confidential Contracts, Inter-Account Transfers

pragma language_version >= 0.13.0;

import CompactStandardLibrary;

// Export types for external use
export { CoinInfo };

// Bank Account structure for the shared ledger
struct BankAccount {
  exists: Boolean,
  owner_hash: Bytes<32>,
  public_key: ZswapCoinPublicKey,
  transaction_count: Uint<32>,
  last_transaction: Bytes<32>,
  status: Bytes<32>,
  created_at: Uint<32>
}

// Authorization structures for Zelle-like transfers
struct TransferAuthorization {
  sender_id: Bytes<32>,
  recipient_id: Bytes<32>,
  shared_encryption_key: Bytes<32>,
  max_amount: Uint<64>,
  created_at: Uint<32>,
  last_updated: Uint<32>
}

struct AuthRequest {
  sender_id: Bytes<32>,
  recipient_id: Bytes<32>,
  requested_at: Uint<32>,
  status: Uint<8>
}

enum AUTH_STATUS {
  pending,
  approved,
  rejected
}

// Public ledger state - ALL ACCOUNTS IN ONE CONTRACT
export ledger all_accounts: Map<Bytes<32>, BankAccount>;  // Maps user_id -> account info
export ledger total_accounts: Counter;                    // Total number of accounts
export ledger last_global_transaction: Bytes<32>;         // Latest transaction hash

// Authorization system for Zelle-like transfers
export ledger active_authorizations: Map<Bytes<32>, TransferAuthorization>; // auth_id -> authorization
export ledger encrypted_balances: Map<Bytes<32>, Bytes<32>>;                // auth_id -> encrypted_balance
export ledger pending_auth_requests: Map<Bytes<32>, AuthRequest>;           // request_id -> request
export ledger user_as_recipient_auths: Map<Bytes<32>, Vector<20, Bytes<32>>>; // user_id -> auth_ids
export ledger user_as_sender_auths: Map<Bytes<32>, Vector<20, Bytes<32>>>;   // user_id -> auth_ids

// Encrypted token amount mappings (contract-wide accessible)
export ledger encrypted_amount_mappings: Map<Bytes<32>, Uint<64>>;          // encrypted_balance -> actual_amount

// Bank Token System (Privacy-Preserving with Encrypted Balance Sharing)
export ledger bank_token_id: Bytes<32>;                                     // Our custom bank token identifier
export ledger encrypted_user_balances: Map<Bytes<32>, Bytes<32>>;           // user_id -> encrypted_balance (private)
export ledger user_balance_mappings: Map<Bytes<32>, Uint<64>>;              // encrypted_balance -> actual_amount
export ledger shared_balance_access: Map<Bytes<32>, Bytes<32>>;             // auth_id -> encrypted_balance_for_verification
export ledger total_token_supply: Uint<64>;                                 // Total bank tokens in circulation
export ledger token_mint_authority: Bytes<32>;                              // Authority that can mint tokens (contract itself)

// Private data (user-specific, stored per user)
witness user_pin_hash(user_id: Bytes<32>): Bytes<32>;
witness user_balance(user_id: Bytes<32>): Uint<64>;
witness set_user_balance(user_id: Bytes<32>, balance: Uint<64>): [];
// Note: Transaction history removed - API handles detailed transaction logging

// Constructor - Initialize empty shared bank with custom token system
constructor() {
  last_global_transaction = pad(32, "bank_initialized");
  
  // Initialize our custom bank token system
  bank_token_id = persistentHash<Bytes<32>>(pad(32, "midnight_bank_token_v1"));
  token_mint_authority = persistentHash<Bytes<32>>(pad(32, "bank_contract_authority"));
  total_token_supply = 0 as Uint<64>;
}

// Circuit 1: Create Account in Shared Bank with Token Deposit
export circuit create_account(user_id: Bytes<32>, initial_pin: Bytes<32>, deposit_amount: Uint<64>): [] {
  // Check account doesn't already exist
  assert (!all_accounts.member(disclose(user_id)), "Account already exists");
  
  assert (deposit_amount >= 10 as Uint<64>, "Minimum deposit is 10 tokens");
  assert (valid_pin_format(initial_pin), "PIN must be valid format");
  
  // Create account identity
  const owner_id = disclose(public_key(initial_pin));
  
  // Create new account in shared ledger
  const new_account = BankAccount {
    exists: true,
    owner_hash: owner_id,
    public_key: ownPublicKey(),
    transaction_count: 1 as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "account_created")),
    status: pad(32, "active"),
    created_at: 1 as Uint<32> // Would be block timestamp in real implementation
  };
  
  all_accounts.insert(disclose(user_id), new_account);
  total_accounts.increment(1);
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "account_created"), user_id]));
  
  // Mint initial bank tokens for the new account (custom token system)
  // This creates tokens in our internal ledger without using Midnight's native token operations
  mint_bank_tokens(disclose(user_id), disclose(deposit_amount), initial_pin);
}

// Circuit 2: Deposit to User Account (Token-Based)
export circuit deposit(user_id: Bytes<32>, pin: Bytes<32>, amount: Uint<64>): [] {
  
  assert (amount > 0 as Uint<64>, "Deposit amount must be positive");
  
  // Get account from shared ledger
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Mint bank tokens for deposit (custom token system)
  mint_bank_tokens(disclose(user_id), disclose(amount), pin);
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "token_deposit")),
    status: pad(32, "active"),
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "token_deposit"), user_id]));
}

// Circuit 3: Withdraw from User Account (Token-Based with Burning)
export circuit withdraw(user_id: Bytes<32>, pin: Bytes<32>, amount: Uint<64>): [] {
  assert (amount > 0 as Uint<64>, "Withdrawal amount must be positive");
  
  // Get account from shared ledger
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Burn bank tokens for withdrawal (custom token system)
  burn_bank_tokens(disclose(user_id), disclose(amount), pin);
  
  // Send equivalent value to user (in practice, this would send external coins)
  // For now, we just burn the tokens - external coin sending would be handled by API
  
  // Update account state
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "token_withdrawal")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  last_global_transaction = disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "token_withdrawal"), user_id]));
}

// Circuit 4: Request Transfer Authorization (Like Adding Contact on Zelle)
export circuit request_transfer_authorization(user_id: Bytes<32>, recipient_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (user_id != recipient_id, "Cannot authorize yourself");
  assert (all_accounts.member(disclose(recipient_id)), "Recipient account does not exist");
  
  // Authenticate sender
  assert (all_accounts.member(disclose(user_id)), "Sender account does not exist");
  const sender_account = all_accounts.lookup(disclose(user_id));
  assert (sender_account.owner_hash == public_key(pin), "Authentication failed");
  
  const request_id = persistentHash<Vector<2, Bytes<32>>>([user_id, recipient_id]);
  
  const request = AuthRequest {
    sender_id: disclose(user_id),
    recipient_id: disclose(recipient_id),
    requested_at: 1, // current timestamp
    status: 0 as Uint<8> // AUTH_STATUS.pending
  };
  
  pending_auth_requests.insert(disclose(request_id), request);
  
  // Update sender's transaction count
  const updated_sender = BankAccount {
    exists: sender_account.exists,
    owner_hash: sender_account.owner_hash,
    public_key: sender_account.public_key,
    transaction_count: (sender_account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "auth_requested")),
    status: sender_account.status,
    created_at: sender_account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_sender);
}

// Circuit 5: Approve Transfer Authorization (One-Time Setup)
export circuit approve_transfer_authorization(user_id: Bytes<32>, sender_id: Bytes<32>, pin: Bytes<32>, max_amount: Uint<64>): [] {
  // 1. Verify request exists
  const request_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  assert (pending_auth_requests.member(disclose(request_id)), "No pending authorization request");
  
  // 2. Authenticate recipient
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  assert (account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Generate shared encryption key and auth_id
  const shared_key = persistentHash<Vector<3, Bytes<32>>>([user_id, sender_id, persistentHash<Bytes<32>>(pin)]);
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  
  // 4. Create authorization
  const authorization = TransferAuthorization {
    sender_id: disclose(sender_id),
    recipient_id: disclose(user_id),
    shared_encryption_key: disclose(shared_key),
    max_amount: disclose(max_amount),
    created_at: 1,
    last_updated: 1
  };
  
  // 5. Store authorization and initialize encrypted transfer amounts to zero
  active_authorizations.insert(disclose(auth_id), authorization);
  const zero_amount = 0 as Uint<64>;
  const encrypted_zero = encrypt_balance(zero_amount, disclose(shared_key));
  encrypted_balances.insert(disclose(auth_id), encrypted_zero);
  
  // 5b. Create shared balance access for the sender so recipient can verify funds
  // Encrypt sender's current balance with the shared key for verification
  const sender_user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(pin)]);
  const sender_encrypted = encrypted_user_balances.member(disclose(sender_id)) ? 
    encrypted_user_balances.lookup(disclose(sender_id)) : encrypt_balance(0 as Uint<64>, sender_user_key);
  const sender_balance = user_balance_mappings.member(sender_encrypted) ? 
    user_balance_mappings.lookup(sender_encrypted) : 0 as Uint<64>;
  const shared_balance_encrypted = encrypt_balance(sender_balance, disclose(shared_key));
  shared_balance_access.insert(disclose(auth_id), shared_balance_encrypted);
  
  // 6. Update lookup tables (simplified - using single entry for now)
  const empty_vector: Vector<20, Bytes<32>> = [pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""),
                                               pad(32, ""), pad(32, ""), pad(32, ""), pad(32, ""), pad(32, "")];
  const recipient_auths = user_as_recipient_auths.member(disclose(user_id)) ? 
    user_as_recipient_auths.lookup(disclose(user_id)) : empty_vector;
  const updated_recipient_auths = [disclose(auth_id), recipient_auths[0], recipient_auths[1], recipient_auths[2], recipient_auths[3],
                                  recipient_auths[4], recipient_auths[5], recipient_auths[6], recipient_auths[7], recipient_auths[8],
                                  recipient_auths[9], recipient_auths[10], recipient_auths[11], recipient_auths[12], recipient_auths[13],
                                  recipient_auths[14], recipient_auths[15], recipient_auths[16], recipient_auths[17], recipient_auths[18]];
  user_as_recipient_auths.insert(disclose(user_id), updated_recipient_auths);
  
  // 7. Clean up request
  pending_auth_requests.remove(disclose(request_id));
  
  // 8. Update account
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "auth_approved")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Circuit 6: Send Tokens to Authorized User
export circuit send_to_authorized_user(user_id: Bytes<32>, recipient_id: Bytes<32>, amount: Uint<64>, pin: Bytes<32>): [] {
  assert (amount > 0 as Uint<64>, "Transfer amount must be positive");
  assert (user_id != recipient_id, "Cannot transfer to yourself");
  
  // 1. Verify authorization exists
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([user_id, recipient_id]);
  assert (active_authorizations.member(disclose(auth_id)), "No authorization - recipient must approve first");
  
  const auth = active_authorizations.lookup(disclose(auth_id));
  assert (amount <= auth.max_amount, "Amount exceeds authorized limit");
  
  // 2. Authenticate sender
  assert (all_accounts.member(disclose(user_id)), "Sender account does not exist");
  const sender_account = all_accounts.lookup(disclose(user_id));
  assert (sender_account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Update shared balance access with current balance RIGHT BEFORE verification
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(pin)]);
  const sender_encrypted = encrypted_user_balances.lookup(disclose(user_id));
  const sender_balance = user_balance_mappings.lookup(sender_encrypted);
  
  // Update the shared balance access for this specific authorization with current balance
  const current_shared_encrypted = encrypt_balance(sender_balance, auth.shared_encryption_key);
  shared_balance_access.insert(disclose(auth_id), current_shared_encrypted);
  
  // Now verify sender has sufficient token balance
  assert (sender_balance >= amount, "Insufficient token balance");
  
  // Deduct from sender's encrypted balance
  const new_sender_balance = (sender_balance - disclose(amount)) as Uint<64>;
  const new_sender_encrypted = encrypt_balance(new_sender_balance, user_key);
  
  // Update sender's balance
  user_balance_mappings.insert(sender_encrypted, 0 as Uint<64>);
  user_balance_mappings.insert(new_sender_encrypted, new_sender_balance);
  encrypted_user_balances.insert(disclose(user_id), new_sender_encrypted);
  
  // Note: Shared balance access was already verified before this transaction
  
  // 4. Store/accumulate pending transfer for recipient to claim later
  const pending_amount = encrypted_balances.member(disclose(auth_id)) ?
    encrypted_balances.lookup(disclose(auth_id)) : encrypt_balance(0 as Uint<64>, auth.shared_encryption_key);

  // Resolve current total (if any) from the public mapping
  const has_mapping = encrypted_amount_mappings.member(pending_amount);
  const current_total = has_mapping ? encrypted_amount_mappings.lookup(pending_amount) : 0 as Uint<64>;
  const new_total = (current_total + amount) as Uint<64>;

  // Encrypt the new total and update mapping and encrypted balance
  const new_encrypted_amount = encrypt_balance(disclose(new_total), disclose(auth.shared_encryption_key));

  // Clear old mapping entry to avoid leaking stale totals
  if (has_mapping) {
    encrypted_amount_mappings.insert(pending_amount, 0 as Uint<64>);
  }
  encrypted_amount_mappings.insert(new_encrypted_amount, disclose(new_total));
  encrypted_balances.insert(disclose(auth_id), new_encrypted_amount);
  
  // 5. Update sender's account
  const updated_sender = BankAccount {
    exists: sender_account.exists,
    owner_hash: sender_account.owner_hash,
    public_key: sender_account.public_key,
    transaction_count: (sender_account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "token_transfer_sent")),
    status: sender_account.status,
    created_at: sender_account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_sender);
  
  last_global_transaction = disclose(persistentHash<Vector<3, Bytes<32>>>([pad(32, "token_transfer"), user_id, recipient_id]));
}

// Circuit 7: Claim Authorized Token Transfer
export circuit claim_authorized_transfer(user_id: Bytes<32>, sender_id: Bytes<32>, pin: Bytes<32>): [] {
  // 1. Verify authorization exists
  const auth_id = persistentHash<Vector<2, Bytes<32>>>([sender_id, user_id]);
  assert (active_authorizations.member(disclose(auth_id)), "No authorization exists");
  
  // 2. Authenticate recipient
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  assert (account.owner_hash == public_key(pin), "Authentication failed");
  
  // 3. Check if there's a pending transfer to claim
  assert (encrypted_balances.member(disclose(auth_id)), "No pending transfer to claim");
  const encrypted_amount = encrypted_balances.lookup(disclose(auth_id));
  
  // 4. Reconstruct shared encryption key and decrypt amount
  const auth = active_authorizations.lookup(disclose(auth_id));
  const shared_key = persistentHash<Vector<3, Bytes<32>>>([user_id, sender_id, persistentHash<Bytes<32>>(pin)]);
  assert (auth.shared_encryption_key == disclose(shared_key), "Invalid encryption key");
  
  // 5. Look up the pending amount from public ledger
  assert (encrypted_amount_mappings.member(encrypted_amount), "No pending transfer found");
  const pending_amount = encrypted_amount_mappings.lookup(encrypted_amount);
  assert (pending_amount > 0 as Uint<64>, "No pending amount to claim");
  
  // 6. Add tokens to recipient's balance using encrypted system
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(pin)]);
  const current_encrypted = encrypted_user_balances.member(disclose(user_id)) ? 
    encrypted_user_balances.lookup(disclose(user_id)) : encrypt_balance(0 as Uint<64>, user_key);
  const current_balance = user_balance_mappings.member(current_encrypted) ? 
    user_balance_mappings.lookup(current_encrypted) : 0 as Uint<64>;
  
  const new_balance = (current_balance + pending_amount) as Uint<64>;
  const new_encrypted = encrypt_balance(new_balance, user_key);
  
  // Update mappings
  if (user_balance_mappings.member(current_encrypted)) {
    user_balance_mappings.insert(current_encrypted, 0 as Uint<64>);
  }
  user_balance_mappings.insert(new_encrypted, new_balance);
  encrypted_user_balances.insert(disclose(user_id), new_encrypted);
  
  // Shared balance access updated lazily in send_to_authorized_user
  
  // 7. Clear the claimed transfer (set to zero) 
  const zero_encrypted = encrypt_balance(0 as Uint<64>, disclose(shared_key));
  encrypted_balances.insert(disclose(auth_id), zero_encrypted);
  
  // Clear the amount mapping from public ledger
  encrypted_amount_mappings.insert(encrypted_amount, 0 as Uint<64>);
  
  // 8. Update recipient's account
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: (account.transaction_count + 1) as Uint<32>,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "token_transfer_claimed")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
  
  last_global_transaction = disclose(persistentHash<Vector<3, Bytes<32>>>([pad(32, "token_transfer_claimed"), sender_id, user_id]));
}

// Circuit 8: Get Token Balance
export circuit get_token_balance(user_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Get encrypted balance using user's PIN
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(pin)]);
  const encrypted_balance = encrypted_user_balances.member(disclose(user_id)) ? 
    encrypted_user_balances.lookup(disclose(user_id)) : encrypt_balance(0 as Uint<64>, user_key);
  const balance = user_balance_mappings.member(encrypted_balance) ? 
    user_balance_mappings.lookup(encrypted_balance) : 0 as Uint<64>;
  
  // Update last transaction to show balance was checked
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: account.transaction_count,
    last_transaction: persistentHash<Bytes<32>>(pad(32, "token_balance_check")),
    status: account.status,
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Circuit 9: Verify Account Status (Token-Based)
export circuit verify_account_status(user_id: Bytes<32>, pin: Bytes<32>): [] {
  assert (all_accounts.member(disclose(user_id)), "Account does not exist");
  const account = all_accounts.lookup(disclose(user_id));
  
  // Authenticate user
  const expected_owner = public_key(pin);
  assert (account.owner_hash == expected_owner, "Authentication failed");
  
  // Verify account properties with encrypted token balance
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(pin)]);
  const encrypted_balance = encrypted_user_balances.member(disclose(user_id)) ? 
    encrypted_user_balances.lookup(disclose(user_id)) : encrypt_balance(0 as Uint<64>, user_key);
  const token_balance = user_balance_mappings.member(encrypted_balance) ? 
    user_balance_mappings.lookup(encrypted_balance) : 0 as Uint<64>;
  assert (token_balance >= 5 as Uint<64>, "Token balance too low for verification");
  assert (account.transaction_count >= 1 as Uint<32>, "Insufficient transaction history");
  
  // Update verification status
  const updated_account = BankAccount {
    exists: account.exists,
    owner_hash: account.owner_hash,
    public_key: account.public_key,
    transaction_count: account.transaction_count,
    last_transaction: account.last_transaction,
    status: pad(32, "verified"),
    created_at: account.created_at
  };
  all_accounts.insert(disclose(user_id), updated_account);
}

// Helper Functions
pure circuit valid_pin_format(pin: Bytes<32>): Boolean {
  const zero_pin = pad(32, "");
  return pin != zero_pin;
}

export pure circuit public_key(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight:bank:pk:"), sk]);
}

// Custom Bank Token Operations (Internal Ledger-Based)
// These functions handle token operations without using Midnight's native token system

// Mint new bank tokens for a user (privacy-preserving with sharing capability)
circuit mint_bank_tokens(user_id: Bytes<32>, amount: Uint<64>, user_pin: Bytes<32>): [] {
  // Create user's personal encryption key from PIN
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(user_pin)]);
  
  // Get current encrypted balance
  const current_encrypted = encrypted_user_balances.member(user_id) ? 
    encrypted_user_balances.lookup(user_id) : encrypt_balance(0 as Uint<64>, user_key);
  
  // Get current actual balance
  const current_balance = user_balance_mappings.member(current_encrypted) ? 
    user_balance_mappings.lookup(current_encrypted) : 0 as Uint<64>;
  
  // Calculate new balance
  const new_balance = (current_balance + amount) as Uint<64>;
  const new_encrypted = encrypt_balance(new_balance, user_key);
  
  // Update mappings
  if (user_balance_mappings.member(current_encrypted)) {
    user_balance_mappings.insert(current_encrypted, 0 as Uint<64>);
  }
  user_balance_mappings.insert(new_encrypted, new_balance);
  encrypted_user_balances.insert(user_id, new_encrypted);
  
  // Shared balance access updated lazily in send_to_authorized_user
  
  // Update total supply
  total_token_supply = (total_token_supply + amount) as Uint<64>;
}

// Burn bank tokens from a user (encrypted balance system)
circuit burn_bank_tokens(user_id: Bytes<32>, amount: Uint<64>, user_pin: Bytes<32>): [] {
  // Get current encrypted balance
  const user_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(user_pin)]);
  const current_encrypted = encrypted_user_balances.member(user_id) ? 
    encrypted_user_balances.lookup(user_id) : encrypt_balance(0 as Uint<64>, user_key);
  
  // Verify user has sufficient balance
  assert (user_balance_mappings.member(current_encrypted), "User has no token balance");
  const current_balance = user_balance_mappings.lookup(current_encrypted);
  assert (current_balance >= amount, "Insufficient token balance to burn");
  
  // Calculate new balance and encrypt
  const new_balance = (current_balance - amount) as Uint<64>;
  const new_encrypted = encrypt_balance(new_balance, user_key);
  
  // Update mappings
  user_balance_mappings.insert(current_encrypted, 0 as Uint<64>);
  user_balance_mappings.insert(new_encrypted, new_balance);
  encrypted_user_balances.insert(user_id, new_encrypted);
  
  // Shared balance access updated lazily in send_to_authorized_user
  
  // Update total supply
  total_token_supply = (total_token_supply - amount) as Uint<64>;
}

// Transfer bank tokens between users (encrypted balance system - requires both PINs)
circuit transfer_bank_tokens(from_user: Bytes<32>, to_user: Bytes<32>, amount: Uint<64>, from_pin: Bytes<32>, to_pin: Bytes<32>): [] {
  // Update sender's balance
  const from_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(from_pin)]);
  const from_encrypted = encrypted_user_balances.lookup(from_user);
  const sender_balance = user_balance_mappings.lookup(from_encrypted);
  assert (sender_balance >= amount, "Insufficient token balance for transfer");
  
  const new_from_balance = (sender_balance - amount) as Uint<64>;
  const new_from_encrypted = encrypt_balance(new_from_balance, from_key);
  
  user_balance_mappings.insert(from_encrypted, 0 as Uint<64>);
  user_balance_mappings.insert(new_from_encrypted, new_from_balance);
  encrypted_user_balances.insert(from_user, new_from_encrypted);
  
  // Update recipient's balance
  const to_key = persistentHash<Vector<2, Bytes<32>>>([pad(32, "user:balance:"), disclose(to_pin)]);
  const to_encrypted = encrypted_user_balances.member(to_user) ? 
    encrypted_user_balances.lookup(to_user) : encrypt_balance(0 as Uint<64>, to_key);
  const recipient_balance = user_balance_mappings.member(to_encrypted) ? 
    user_balance_mappings.lookup(to_encrypted) : 0 as Uint<64>;
  
  const new_to_balance = (recipient_balance + amount) as Uint<64>;
  const new_to_encrypted = encrypt_balance(new_to_balance, to_key);
  
  if (user_balance_mappings.member(to_encrypted)) {
    user_balance_mappings.insert(to_encrypted, 0 as Uint<64>);
  }
  user_balance_mappings.insert(new_to_encrypted, new_to_balance);
  encrypted_user_balances.insert(to_user, new_to_encrypted);
  
  // Shared balance access updated lazily in send_to_authorized_user
}

// Helper Functions for Encryption (Authorization System)
// Using XOR with key derivation for symmetric encryption/decryption
pure circuit encrypt_balance(balance: Uint<64>, encryption_key: Bytes<32>): Bytes<32> {
  // Convert balance to bytes for XOR encryption
  const balance_bytes = pad(32, "");
  // Simple but secure XOR encryption - in production would use AES or similar
  const encrypted = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Uint<64>>(balance), 
    encryption_key
  ]);
  return encrypted;
}

// Note: Shared balance access is now updated lazily in send_to_authorized_user
// right before verification - much more efficient!